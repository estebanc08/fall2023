Single-pair shortest path problem
    Problem: Given a diagraph G=(V,E), edge lengths ‚Ñì_e >= 0, sources s elem of V, and destination t elem of V, find a shortest directed path from s to t

Single-source shortest paths problem
    Problem: Given a digraph G = (V, E), edge lengths ‚Ñìe ‚â• 0, source s ‚àà V, find a shortest directed path from s to every node

Shortest path applications
„ÉªPERT/CPM                  „ÉªNetwork routing protocols (OSPF, BGP, RIP) 
„ÉªMap routing               „ÉªRouting of telecommunications messages 
„ÉªSeam carving              „ÉªTelemarketer operator scheduling 
„ÉªRobot navigation          „ÉªUrban traffic planning 
„ÉªTexture mapping           „ÉªTypesetting in LaTeX 
„ÉªOptimal truck routing through given traffic congestion pattern 

Dijkstra‚Ä≤s algorithm (for single-source shortest paths problem)
    Greedy approach: Maintain a set of explored nodes S for which algorithm has determined d[u] = length of a shortest s‚Üùu path.
    „ÉªInitialize S ‚Üê { s }, d[s] ‚Üê 0.
    „ÉªRepeatedly choose unexplored node v ‚àâ S which minimizes
    „Éªùùø (v) = min_{e=(u,v): u elem of S} d[u]+l_e and add v to S and set d[v] <- ùùø (v)
    „ÉªTo recover path, set pred[v] ‚Üê e that achieves min

Dijkstras algorithm: proof of correctness
    Invariant. For each node u ‚àà S : d[u] = length of a shortest s‚Üùu path.
    Pf. [ by induction on ‚éúS‚éü ]
    Base case: ‚éúS‚éü = 1 is easy since S = { s } and d[s] = 0.
    Inductive hypothesis: Assume true for ‚éúS‚éü ‚â• 1.
        „ÉªLet v be next node added to S, and let (u, v) be the final edge.
        „ÉªA shortest s‚Üù u path plus (u, v) is an s‚Üù v path of length œÄ(v).
        „ÉªConsider any other s‚Üù v path P. We show that it is no shorter than œÄ(v).
        „ÉªLet e = (x, y) be the first edge in P that leaves S, and let P‚Ä≤ be the subpath from s to x.
        „ÉªThe length of P is already ‚â• œÄ (v) as soon as it reaches y

Dijkstra‚Ä≤s algorithm: efficient implementation
    * Critical optimization 1. For each unexplored node v ‚àâ S : explicitly maintain œÄ[v] instead of computing directly from definition
        „ÉªFor each v ‚àâ S : œÄ(v) can only decrease (because set S increases).
        „ÉªMore specifically, suppose u is added to S and there is an edge e = (u, v) leaving u. Then, it suffices to update:
            œÄ [v] ‚Üê min { œÄ[v], œÄ[u] + ‚Ñìe) }
    * Critical optimization 2. Use a min-oriented priority queue (PQ) to choose an unexplored node that minimizes œÄ[v].
    * Implementation.
        „ÉªAlgorithm maintains œÄ[v] for each node v.
        „ÉªPriority queue stores unexplored nodes, using œÄ[ ‚ãÖ] as priorities.
        „ÉªOnce u is deleted from the PQ, œÄ[u] = length of a shortest s‚Üù u path.
                DIJKSTRA (V, E, ‚Ñì, s)
                FOREACH v ‚â† s : œÄ[v] ‚Üê ‚àû, pred[v] ‚Üê null; œÄ[s] ‚Üê 0.
                Create an empty priority queue pq.
                FOREACH v ‚àà V : INSERT(pq, v, œÄ[v]).
                WHILE (IS-NOT-EMPTY(pq))
                    u ‚Üê DEL-MIN(pq).
                        FOREACH edge e = (u, v)‚àà E leaving u:
                        IF (œÄ[v] > œÄ[u] + ‚Ñìe)
                            DECREASE-KEY(pq, v, œÄ[u] + ‚Ñìe).
                            œÄ[v] ‚Üê œÄ[u] + ‚Ñìe ; pred[v] ‚Üê e.
    * Performance: Depends on PQ: n INSERT, n DELETE-MIN, ‚â§ m DECREASE-KEY.
        „ÉªArray implementation optimal for dense graphs.
        „ÉªBinary heap much faster for sparse graphs.
        „Éª4-way heap worth the trouble in performance-critical situations
